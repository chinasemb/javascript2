<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
<script>
/*
    在使用简单类型的属性或者方法的时候，系统偷偷地把该数据类型的
    内置对象调出来，去获取属性或者方法，使用完之后再偷偷地销毁

    valueOf() 获取对应类型的原始值

    for...in


    A  instanceof  B
        左值是否为右值的实例化对象

    obj.hasOwnProperty(attr)
        检查自身的属性

    obj.constructor
        查看某个对象的构造函数是谁
    
        注意：
            这个指向容易变（在赋址的时候就会变）,就算变了，并不影响代码的执行
            辅助查看的作用

            如果改了，那么手动修正即可

    继承:
        拷贝继承
            调用父类通过call的方式修正指向（属性的继承）
            for in 
                只拷贝父类原型自身的属性
        原型继承
            调用父类通过call的方式修正指向（属性的继承）
            通过炮灰来进行联系

            构造函数的原型中的方法或者属性只给实例化对象使用

            只要实例化对象上没有某个属性或者方法就一定会去
            构造函数下的原型去找

            paohui.prototype = {1}

            let ph = new paohui  {2}

            ph.move

            Drag2.prototype = new paohui



*/

    let str = new String('miaov'); //'miaov'

    // console.log(str.valueOf());

    // Object.prototype.fn = '函数';
    // let obj = {name:'90-ING'};
    // console.log("fn" in  obj);
    // console.log(obj.hasOwnProperty('fn'));

    function Person(name){
        this.name = name;
    }

    let obj2 = {
        constructor:Person,
        say:function(){
            alert(123);
        },
        runing:function() {
            alert('我会跑');
        }
    }
    Person.prototype = obj2;

    let p = new Person('兔子');




    p.runing();

    let arr = [];

    // console.log(arr.constructor == Array);

    // p.constructor
    console.dir(p.constructor);





</script>
</body>
</html>